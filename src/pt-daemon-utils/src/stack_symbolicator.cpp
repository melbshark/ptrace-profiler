////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "stack_symbolicator.h"

#include "addr2line.h"

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

StackSymbolicator::StackSymbolicator (MemoryMapManager *mmapManager, Addr2Line *add2line)
  : m_mmapManager (mmapManager)
  , m_addr2line (add2line)
  , m_currentToken (0)
{

}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void StackSymbolicator::Preprocess (StackCorkscrew *corkscrew)
{
  const size_t stackSize = corkscrew->GetNumFrames ();

  for (size_t i = 0; i < stackSize; ++i)
  {
    StackFrame &frame = corkscrew->m_frames [i];

    // 
    // Find a token for this frame's PC address.
    // 

    {
      auto it = m_tokensByPc.find (frame.m_pc);

      if (it != m_tokensByPc.end ())
      {
        frame.m_functionToken = it->second;
      }
      else
      {
        frame.m_functionToken = ++m_currentToken;

        std::pair <uint64_t, StackToken> entry (frame.m_pc, frame.m_functionToken);

        m_tokensByPc.insert (entry);
      }
    }

    // 
    // Check for previously mapped/symbolicated results for this token. 
    // Otherwise, insert a new symbolication entry.
    // 

    {
      auto it = m_locationsByToken.find (frame.m_functionToken);

      if (it != m_locationsByToken.end ())
      {
        const std::string &function = it->second;

        strncpy (frame.m_function, function.c_str (), sizeof (frame.m_function));

        frame.m_function [sizeof (frame.m_function) - 1] = '\0';
      }
      else
      {
        const MemoryMapRegion *map = m_mmapManager->FindMapForAddress (frame.m_pc);

        if (map)
        {
          const uint64_t offset = (frame.m_pc - map->start) + map->offset; // TODO: do something with map->offset too?

          snprintf (frame.m_function, sizeof (frame.m_function), "%s!0x%llx", map->pathname, offset);
        }
        else
        {
          snprintf (frame.m_function, sizeof (frame.m_function), "%s!0x%llx", "??", frame.m_pc);
        }

        std::string function = frame.m_function;

        std::pair <uint32_t, std::string> entry (frame.m_functionToken, function);

        m_locationsByToken.insert (entry);
      }
    }
  }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void StackSymbolicator::Symbolicate ()
{
  auto it = m_locationsByToken.begin ();

  while (it != m_locationsByToken.end ())
  {
    size_t pos = it->second.find ('!');

    if (pos != std::string::npos)
    {
      std::string lib = it->second.substr (0, pos);

      std::string address = it->second.substr (pos + 1);

      m_addr2line->Symbolicate (lib, address, &it->second);
    }

    it++;
  }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
